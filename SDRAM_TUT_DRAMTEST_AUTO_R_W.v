//Author: Andrew Boelbaai
//Email:acawhiz@gmail.com
//Date 2020-April
//Version 1.0.0
//Language:Verilog
//Target SDRAM CONTROLLER tester
//
//PLATFORM DE10-LITE
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
////DRAM_TESTER_V1.0.0.0_auto_read_write
module SDRAM_TUT_DRAMTEST_AUTO_R_W(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire [24:0] ADDRESS;// = 25'd0;
//wire WR_REQUEST_APPROVED;
//wire RD_REQUEST_APPROVED;
wire [15:0] DATA_READ;
wire reset_DRAM_CTRL;

reg [27:0] reset_release = 28'h0000_0000;
reg [24:0] ADDR_COUNTER_WRITE = 25'd0;
reg [24:0] ADDR_COUNTER_READ=25'd0;

reg [24:0] DATA_SEG=24'd0;
reg [15:0] DATA_WRITE;
reg [31:0] blink=32'd0;



//=======================================================
//  Structural coding
//=======================================================

wire pll_c2_to_slow_clk;
wire KEY_1;
wire clk_c0;//100MHZ
wire clk_c1;//100MHZ-3ns for DRAM

reg write_pulse=1'b0;
reg read_pulse=1'b0;
reg KEY_0_pressed=1'b0;


sdram_pll0 pll1(
	.areset(),
	.inclk0(MAX10_CLK1_50),
	.c0(clk_c0),
	.c1(clk_c1),
	.c2(pll_c2_to_slow_clk),
	.locked());
	
debouncer debouncer_KEY0(
	.slow_clk(pll_c2_to_slow_clk),
	.btn_in(KEY[0]),
	.btn_out(KEY_0)
);
	
debouncer debouncer_KEY1(
	.slow_clk(pll_c2_to_slow_clk),
	.btn_in(KEY[1]),
	.btn_out(KEY_1)
);

SEG7_LUT_6 display(	
.oSEG0(HEX0),
.oSEG1(HEX1),
.oSEG2(HEX2),
.oSEG3(HEX3),
.oSEG4(HEX4),
.oSEG5(HEX5),
.iDIG(DATA_SEG[23:0]) );



SDRAM_CTRL(
			.RE(read_pulse),
			.WR(write_pulse),
			.ADDR(ADDRESS),//in 24:0
			.oRD_DATA_READY(),//out
			.RD_REQUEST_APPROVED(RD_REQUEST_APPROVED),//out
			.WR_REQUEST_APPROVED(WR_REQUEST_APPROVED),
	  		.RD_DATA(DATA_READ),//out 15:0
			.WR_DATA(DATA_WRITE),//out 15:0
			.MAX10_CLK1_100(clk_c0),
	 		.MAX10_CLK2_100_3ns(clk_c1),
			.DRAM_ADDR(DRAM_ADDR),
		   .DRAM_BA(DRAM_BA),
		   .DRAM_CAS_N(DRAM_CAS_N),
		   .DRAM_CKE(DRAM_CKE),
		   .DRAM_CLK(DRAM_CLK),
	      .DRAM_CS_N(DRAM_CS_N),
			.DRAM_DQ(DRAM_DQ),
	      .DRAM_LDQM(DRAM_LDQM),
	      .DRAM_RAS_N(DRAM_RAS_N),
	      .DRAM_UDQM(DRAM_UDQM),
	      .DRAM_WE_N(DRAM_WE_N),
			.LEDR(LEDR[4:0]),//machine state
			.reset_n(reset_DRAM_CTRL));
//=======================================================
//  Structural coding test
//=======================================================
// / //////////////////////////////////////////////
// reset_n and start_n control

always @ (posedge clk_c0)
begin
	if(reset_release<28'h1DCD6500)//2 sec
		reset_release<=reset_release+1;
	
end

//Off=reset active Blink=Reset off 
assign reset_DRAM_CTRL=(reset_release==28'h1DCD6500)?1:0;
assign LEDR[9]=reset_DRAM_CTRL & blink[23] ;//ready light

//active bank indicator					
assign LEDR[6:5]=ADDRESS[24:23];

//multiplexing read and write adress counters
assign ADDRESS=(write_report==1)?ADDR_COUNTER_WRITE:ADDR_COUNTER_READ;


//display address or data
//always @ (ADDRESS or RD_REQUEST_APPROVED)
always @(negedge MAX10_CLK1_50)
begin
	case(SW[1])
		1'b0:DATA_SEG<=ADDRESS[23:0];//loosing msb//switch down
		1'b1:DATA_SEG<=DATA_READ;//switch up
		default:DATA_SEG<=23'b1;
	endcase
	
end

always @ (posedge MAX10_CLK1_50)
begin
	blink <= blink + 1'b1;
end


/////////////////////auto read test//////////////////////////
integer sm_read_state=0;
integer read_report=0;
	
always @ (posedge MAX10_CLK1_50)
begin
	
	if(reset_DRAM_CTRL==1'b1 & KEY_0==1'b1 & sm_read_state==0) begin
		ADDR_COUNTER_READ=25'd0;
		read_pulse = 1'b0;
		sm_read_state = 1;
		end
	
	else if (sm_read_state==1)	begin//read enable
			read_pulse = 1'b1;
			sm_read_state = 2;
			read_report=1;
		end
		
	else if(sm_read_state==2) begin
			if(RD_REQUEST_APPROVED) begin//wait for RD_REQUEST_APPROVED=1
				read_pulse = 1'b0;
				sm_read_state = 3;
				end 
		end
	else if(sm_read_state==3) begin//wait for RD_REQUEST_APPROVED=0
			if(!RD_REQUEST_APPROVED) begin
				sm_read_state = 4;
				end
		end
		
	else if(sm_read_state==4) begin//compare
		
			if(DATA_READ==ADDR_COUNTER_READ[15:0]) begin
				
					if (ADDR_COUNTER_READ!={25{1'b1}})begin
						ADDR_COUNTER_READ = ADDR_COUNTER_READ + 1;
						sm_read_state = 1; //next read pulse
						end
					else
						begin
							read_report=2;
							sm_read_state = 5;//all adress read
						end
			end
			else begin//match fail
				sm_read_state=5;
				read_report=3;
			end
	end	

	else if(sm_read_state==5) begin//stop	wait for 0: In case Key_0 still up
				if(KEY_0==1'b0) 
					sm_read_state = 6;
	end
			
	else if(sm_read_state==6) begin//stop	wait for 1:KEY_0 press
				if(KEY_0==1'b1) 
					sm_read_state = 0;
	end
	
			
end
assign LEDR[7]=(read_report==1)?blink[23]://in progress
					(read_report==2)?1'b1:1'b0;//On== complete. Off==mismatch data
/////////////////////end auto read test//////////////////////////



/////////////////////auto write test//////////////////////////
integer sm_write_state=0;
integer write_report=0;
	
always @ (posedge MAX10_CLK1_50)
begin
	
	if(reset_DRAM_CTRL==1'b1 & KEY_1==1'b1 & sm_write_state==0) begin
		ADDR_COUNTER_WRITE=25'd0;
		write_pulse = 1'b0;
		sm_write_state = 1;
		end
	
	else if (sm_write_state==1)	begin//write enable
			if (ADDR_COUNTER_WRITE==25'h2baaaad  & SW[9])//insert bug in bank 2 for memory read to catch
						DATA_WRITE=15'h3210;
			else
						DATA_WRITE=ADDR_COUNTER_WRITE[15:0];
						
			write_pulse = 1'b1;
			sm_write_state = 2;
			write_report=1;
		end
		
	else if(sm_write_state==2) begin
			if(WR_REQUEST_APPROVED) begin//wait for WR_REQUEST_APPROVED=1
				write_pulse = 1'b0;
				sm_write_state = 3;
				end 
	end
	
	else if(sm_write_state==3) begin//wait for WR_REQUEST_APPROVED=0
			if(!WR_REQUEST_APPROVED) begin
				sm_write_state = 4;
			end
	end
	
	else if(sm_write_state==4) begin//increment address
		
			if (ADDR_COUNTER_WRITE!={25{1'b1}})begin
						ADDR_COUNTER_WRITE = ADDR_COUNTER_WRITE + 1;
						sm_write_state = 1; //next write pulse
						end
					else begin
							write_report=2;
							sm_write_state = 5;//all adress write
					end
						
	end	

	else if(sm_write_state==5) begin//stop	wait for 0: In case Key_1 still up
				if(KEY_1==1'b0) 
					sm_write_state = 6;
	end
			
	else if(sm_write_state==6) begin//stop	wait for 1:KEY_1 press
				if(KEY_1==1'b1) 
					sm_write_state = 0;
	end
	
			
end
assign LEDR[8]=(write_report==1)?blink[23]://Write in progress
					(write_report==2)?1'b1:1'b0;//write complete
/////////////////////end auto write test//////////////////////////

//=======================================================
//  END Structural coding test
//=======================================================

endmodule
